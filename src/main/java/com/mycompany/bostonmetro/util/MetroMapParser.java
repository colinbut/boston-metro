package com.mycompany.bostonmetro.util;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.StringTokenizer;import com.mycompany.bostonmetro.MetroMap;import com.mycompany.bostonmetro.exception.BadFileException;import com.mycompany.bostonmetro.exception.MetroMapParsingException;import com.mycompany.bostonmetro.model.Station;import com.mycompany.bostonmetro.model.StationInfo;/** * This class reads a text description of a metro subway system and generates a * graph representation of the metro. * * <p> * * The grammar for the file is described below in BNF. A typical line in the * file looks like this : * * <code> 20 NorthStation   Green 19 22  Orange 15 22  </code> * * where : 20 is the StationID NorthStation is the StationName Green 19 22 Green * is the LineName 19 is the StationID of the outbound station 22 is the * StationID of the inbound station Orange 15 22 is a LineID in which : Orange * is the LineName 15 is the StationID of the outbound station 22 is the * StationID of the inbound station * * Therefore, NorthStation has two outgoing lines. * * note : 0 denotes the end of a line : i.e. in this case, OakGrove would be at * the end of the line, as there is no other outbound station. * * <p> * metro-map ::= station-spec* <BR> * station-spec ::= station-id station-name station-line+ <BR> * station-id ::= (positive integer) <BR> * station-name ::= string <BR> * station-line ::= line-name station-id station-id <BR> * */public class MetroMapParser {	private BufferedReader fileInput;	private MetroMap newGraph;	public MetroMap getMetroMap() {		return newGraph;	}	/**	 * @effects: creates a new parser that will read from the file filename	 *           unless the file does not exist. The filename should specify the	 *           exact location of the file. This means it should be something	 *           like /mit/$USER/6.170/ex3/bostonmetro.txt	 *	 * 	 * @throws java.io.IOException	 *             if there <tt>filename</tt> cannot be read	 *	 * @returns a new MetroMapParser that will parse the file filename	 */	public MetroMapParser(String filename) throws IOException {		// a buffered reader reads line by line, returning null when file is		// done		fileInput = new BufferedReader(new FileReader(filename));		newGraph = new MetroMap();	}	/**	 * 	 * @throws IOException	 * @throws BadFileException	 */	public void buildMetroMap() throws IOException, BadFileException {		generateStationList();		generateGraphFromFile();	}	/**	 * @effects: parses the file, and generates a graph from it, unless there is	 *           a problem reading the file, or there is a problem with the	 *           format of the file.	 *	 * @throws java.io.IOException	 *             if there is a problem reading the file	 * @throws ex3.BadFileException	 *             if there is a problem with the format of the file	 *	 * @returns the Graph generated by the file	 */	public void generateStationList() throws BadFileException, IOException {		fileInput.mark(10000);		String line = fileInput.readLine();		StringTokenizer st;		String stationID;		String stationName;		while (line != null) {			st = new StringTokenizer(line);			if (!st.hasMoreTokens()) {				line = fileInput.readLine();				continue;			}			stationID = st.nextToken();						if (!st.hasMoreTokens()) {				throw new MetroMapParsingException("no station name");			}			stationName = st.nextToken();			StationInfo s = new StationInfo(stationID, stationName);						Station currentStation = new Station(s);			newGraph.addNode(currentStation);			line = fileInput.readLine();		}	}	/**	 * 	 * @throws BadFileException	 * @throws IOException	 */	public void generateGraphFromFile() throws BadFileException, IOException {		fileInput.reset();		String line = fileInput.readLine();		StringTokenizer st;		Station currentStation, nextStation;		String outboundID, inboundID;		while (line != null) {			// StringTokenizer is a java.util Class that can break a string into			// tokens			// based on a specified delimiter. The default delimiter is			// " \t\n\r\f" which			// corresponds to the space character, the tab character, the			// newline character,			// the carriage-return character and the form-feed character.			st = new StringTokenizer(line);			// We want to handle empty lines effectively, we just ignore them!			if (!st.hasMoreTokens()) {				line = fileInput.readLine();				continue;			}			// from the grammar, we know that the Station ID is the first token			// on the line			String stationID = st.nextToken();			currentStation = new Station();			nextStation = new Station();			if (!st.hasMoreTokens()) {				throw new MetroMapParsingException("no station name");			}			// from the grammar, we know that the Station Name is the second			// token on the line.			String stationName = st.nextToken();			if (!st.hasMoreTokens()) {				throw new MetroMapParsingException("station is on no lines");			}			while (st.hasMoreTokens()) {				String label = st.nextToken();				/*				 * if(!st.hasMoreTokens()){ throw new				 * IOException("poorly formatted line info"); }				 */				// ******************1st number				outboundID = st.nextToken();				if (outboundID.equals("0")) {					currentStation = (Station) newGraph.getNode(stationID);				} else {					currentStation = (Station) newGraph.getNode(stationID);					nextStation = (Station) newGraph.getNode(outboundID);					newGraph.addEdge(currentStation, nextStation, label);				}				if (!st.hasMoreTokens()) {					throw new IOException("poorly formatted adjacent stations");				}				// *******************2nd number				inboundID = st.nextToken();				if (inboundID.equals("0")) {					nextStation = (Station) newGraph.getNode(stationID);				} 				else {					currentStation = (Station) newGraph.getNode(stationID);					nextStation = (Station) newGraph.getNode(inboundID);					newGraph.addEdge(currentStation, nextStation, label);				}			}			line = fileInput.readLine();		}	}}